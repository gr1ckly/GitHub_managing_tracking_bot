CREATE TYPE FILE_STATE AS ENUM ('ADDED', 'MODIFIED', 'DELETED');

CREATE TABLE USERS(
    ID SERIAL PRIMARY KEY,
    CHAT_ID BIGINT UNIQUE NOT NULL,
    USERNAME TEXT,
    CREATED_AT TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE TOKENS(
    ID SERIAL PRIMARY KEY,
    USER_ID INT UNIQUE NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE,
    TOKEN VARCHAR(256) UNIQUE NOT NULL,
    CREATED_AT TIMESTAMPTZ DEFAULT now(),
    LAST_VALIDATE_AT TIMESTAMPTZ
);

CREATE TABLE REPOS(
    ID SERIAL PRIMARY KEY,
    URL TEXT NOT NULL UNIQUE,
    OWNER TEXT,
    NAME TEXT,
    ADDED_AT TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE USER_REPOS (
    USER_ID INT NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE,
    REPO_ID INT NOT NULL REFERENCES REPOS(ID) ON DELETE CASCADE,
    ADDED_AT TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (USER_ID, REPO_ID)
);

CREATE TABLE BRANCHES(
    ID SERIAL PRIMARY KEY,
    REPO_ID INT NOT NULL REFERENCES REPOS(ID) ON DELETE CASCADE,
    NAME TEXT NOT NULL,
    LAST_COMMIT_ID BIGINT,
    UNIQUE (REPO_ID, NAME)
);

CREATE TABLE FILES(
    ID SERIAL PRIMARY KEY,
    REPO_ID INT NOT NULL REFERENCES REPOS(ID) ON DELETE CASCADE,
    STATE FILE_STATE NOT NULL,
    PATH TEXT NOT NULL,
    STORAGE_KEY TEXT,
    CREATED_AT TIMESTAMPTZ DEFAULT now(),
    UPDATED_AT TIMESTAMPTZ DEFAULT now(),
    UNIQUE (REPO_ID, PATH)
);

CREATE TABLE COMMITS(
    ID BIGSERIAL PRIMARY KEY,
    REPO_ID INT NOT NULL REFERENCES REPOS(ID) ON DELETE CASCADE,
    BRANCH_ID INT REFERENCES BRANCHES(ID) ON DELETE SET NULL,
    COMMIT_HASH TEXT,
    AUTHOR_ID INT REFERENCES USERS(ID),
    MESSAGE TEXT,
    PUSHING BOOLEAN,
    CREATED_AT TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE COMMIT_FILES (
    COMMIT_ID BIGINT NOT NULL REFERENCES COMMITS(ID) ON DELETE CASCADE,
    FILE_ID INT NOT NULL REFERENCES FILES(ID) ON DELETE CASCADE,
    PRIMARY KEY (COMMIT_ID, FILE_ID)
);

CREATE TABLE EDITOR_SESSIONS (
    ID BIGSERIAL PRIMARY KEY,
    FILE_ID INT NOT NULL REFERENCES FILES(ID) ON DELETE CASCADE,
    SESSION_URL TEXT NOT NULL,
    FOR_USER INT REFERENCES USERS(ID),
    CREATED_AT TIMESTAMPTZ DEFAULT now(),
    EXPIRES_AT TIMESTAMPTZ
);

CREATE TABLE NOTIFICATIONS (
    ID SERIAL PRIMARY KEY,
    USER_ID INT NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE,
    REPO_ID INT NOT NULL REFERENCES REPOS(ID) ON DELETE CASCADE,
    LAST_COMMIT BIGINT REFERENCES COMMITS(ID),
    ENABLED BOOLEAN DEFAULT TRUE,
    CREATED_AT TIMESTAMPTZ DEFAULT now(),
    UNIQUE (USER_ID, REPO_ID)
);

CREATE INDEX USERS_CHAT_ID_IND ON USERS USING HASH (CHAT_ID);

CREATE INDEX FILES_REPO_PATH_IND ON FILES(REPO_ID, PATH);

CREATE INDEX COMMITS_REPO_CREATED_IND ON COMMITS(REPO_ID, CREATED_AT);

CREATE INDEX NOTIFICATIONS_REPO_IND ON NOTIFICATIONS(REPO_ID);

CREATE INDEX TOKEN_USER_IND ON TOKENS(USER_ID);

CREATE INDEX USER_REPOS_IND ON USER_REPOS(USER_ID);

CREATE OR REPLACE FUNCTION UPDATE_FILES_UPDATED_TIME()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.UPDATED_AT := now();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

CREATE TRIGGER FILES_UPDATED_AT
    BEFORE UPDATE ON FILES
    FOR EACH ROW
    EXECUTE FUNCTION UPDATE_FILES_UPDATED_TIME();

CREATE OR REPLACE FUNCTION UPDATE_BRANCH_LAST_COMMIT()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.BRANCH_ID IS NOT NULL THEN
        UPDATE BRANCHES
        SET LAST_COMMIT_ID = NEW.ID
        WHERE ID = NEW.BRANCH_ID;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER UPDATE_BRANCH_LAST_COMMIT_TRIGGER
AFTER INSERT ON COMMITS
FOR EACH ROW
EXECUTE FUNCTION UPDATE_BRANCH_LAST_COMMIT();
